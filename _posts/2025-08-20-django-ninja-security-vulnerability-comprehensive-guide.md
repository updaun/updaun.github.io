---
layout: post
title: "Django & Django Ninja ë³´ì•ˆ ì™„ì „ ê°€ì´ë“œ: ì·¨ì•½ì  ë¶„ì„ê³¼ ëŒ€ì‘ ë°©ì•ˆ"
date: 2025-08-20 10:00:00 +0900
categories: [Django, Security, Web Development]
tags: [Django, Django-Ninja, Security, Vulnerability, OWASP, Authentication, Authorization, XSS, CSRF, SQL Injection]
---

ì›¹ ì• í”Œë¦¬ì¼€ì´ì…˜ ë³´ì•ˆì€ ê°œë°œìê°€ ë°˜ë“œì‹œ ê³ ë ¤í•´ì•¼ í•  í•µì‹¬ ìš”ì†Œì…ë‹ˆë‹¤. DjangoëŠ” ê¸°ë³¸ì ìœ¼ë¡œ ë§ì€ ë³´ì•ˆ ê¸°ëŠ¥ì„ ì œê³µí•˜ì§€ë§Œ, Django Ninjaì™€ í•¨ê»˜ ì‚¬ìš©í•  ë•Œ ì¶”ê°€ì ì¸ ë³´ì•ˆ ê³ ë ¤ì‚¬í•­ë“¤ì´ ìˆìŠµë‹ˆë‹¤. ì´ ê¸€ì—ì„œëŠ” Djangoì™€ Django Ninjaì˜ ì£¼ìš” ë³´ì•ˆ ì·¨ì•½ì ê³¼ ëŒ€ì‘ ë°©ì•ˆì„ ìƒì„¸íˆ ë‹¤ë£¨ê² ìŠµë‹ˆë‹¤.

## ğŸ”’ Django ê¸°ë³¸ ë³´ì•ˆ ê¸°ëŠ¥

DjangoëŠ” OWASP Top 10 ì·¨ì•½ì  ëŒ€ë¶€ë¶„ì„ ê¸°ë³¸ì ìœ¼ë¡œ ë°©ì–´í•©ë‹ˆë‹¤:

### 1. CSRF (Cross-Site Request Forgery) ë³´í˜¸

**Djangoì˜ ê¸°ë³¸ CSRF ë³´í˜¸:**
```python
# settings.py
MIDDLEWARE = [
    'django.middleware.csrf.CsrfViewMiddleware',  # CSRF ë³´í˜¸ í™œì„±í™”
    # ... ë‹¤ë¥¸ ë¯¸ë“¤ì›¨ì–´ë“¤
]

# í…œí”Œë¦¿ì—ì„œ CSRF í† í° ì‚¬ìš©
{% raw %}{% csrf_token %}{% endraw %}
```

**Django Ninjaì—ì„œì˜ CSRF ì²˜ë¦¬:**
```python
# api.py
from ninja import NinjaAPI
from django.middleware.csrf import get_token
from django.views.decorators.csrf import csrf_exempt
from django.utils.decorators import method_decorator

api = NinjaAPI()

# CSRF í† í° ì œê³µ ì—”ë“œí¬ì¸íŠ¸
@api.get("/csrf-token")
def get_csrf_token(request):
    return {"csrfToken": get_token(request)}

# CSRF ë³´í˜¸ê°€ í•„ìš”í•œ API
@api.post("/protected-endpoint")
def protected_endpoint(request, data: dict):
    # CSRF í† í°ì€ ìë™ìœ¼ë¡œ ê²€ì¦ë¨
    return {"message": "ì„±ê³µ"}

# CSRF ë³´í˜¸ ë¹„í™œì„±í™” (ì£¼ì˜í•´ì„œ ì‚¬ìš©)
@method_decorator(csrf_exempt, name='dispatch')
class UnsafeAPI:
    @api.post("/unsafe-endpoint")
    def unsafe_endpoint(self, request):
        return {"message": "CSRF ë³´í˜¸ ì—†ìŒ"}
```

### 2. XSS (Cross-Site Scripting) ë³´í˜¸

**Django í…œí”Œë¦¿ ìë™ ì´ìŠ¤ì¼€ì´í”„:**
```python
# views.py
def user_profile(request):
    user_input = request.GET.get('comment', '')
    return render(request, 'profile.html', {
        'comment': user_input  # ìë™ìœ¼ë¡œ HTML ì´ìŠ¤ì¼€ì´í”„ë¨
    })
```

**Django Ninjaì—ì„œ XSS ë°©ì§€:**
```python
# schemas.py
from ninja import Schema
from pydantic import validator
import html
import re

class CommentSchema(Schema):
    content: str
    author: str
    
    @validator('content')
    def sanitize_content(cls, v):
        # HTML íƒœê·¸ ì œê±°
        clean_content = re.sub(r'<[^>]+>', '', v)
        # HTML ì—”í‹°í‹° ì´ìŠ¤ì¼€ì´í”„
        return html.escape(clean_content)
    
    @validator('author')
    def sanitize_author(cls, v):
        return html.escape(v.strip())

# api.py
@api.post("/comments")
def create_comment(request, comment: CommentSchema):
    # ì´ë¯¸ sanitizeëœ ë°ì´í„°
    return {"message": "ëŒ“ê¸€ì´ ì•ˆì „í•˜ê²Œ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤"}
```

### 3. SQL Injection ë°©ì§€

**Django ORM ì‚¬ìš© ì‹œ ìë™ ë°©ì§€:**
```python
# ì•ˆì „í•œ ë°©ì‹ (Django ORM)
def get_user_posts(request, user_id: int):
    posts = Post.objects.filter(author_id=user_id)  # íŒŒë¼ë¯¸í„° ë°”ì¸ë”©ìœ¼ë¡œ ì•ˆì „
    return posts

# ìœ„í—˜í•œ ë°©ì‹ (Raw SQL - í”¼í•´ì•¼ í•¨)
def unsafe_get_posts(request, user_id: str):
    # SQL Injection ì·¨ì•½ì  ì¡´ì¬
    query = f"SELECT * FROM posts WHERE author_id = {user_id}"
    return Post.objects.raw(query)

# ì•ˆì „í•œ Raw SQL ì‚¬ìš©ë²•
def safe_raw_query(request, user_id: int):
    query = "SELECT * FROM posts WHERE author_id = %s"
    return Post.objects.raw(query, [user_id])
```

## ğŸ›¡ï¸ Django Ninja íŠ¹í™” ë³´ì•ˆ êµ¬í˜„

### 1. JWT ì¸ì¦ ì‹œìŠ¤í…œ ë³´ì•ˆ

```python
# authentication.py
from ninja.security import HttpBearer
from django.contrib.auth.models import User
from django.http import HttpRequest
import jwt
from datetime import datetime, timedelta
import secrets
import logging

logger = logging.getLogger('security')

class SecureJWTAuth(HttpBearer):
    def __init__(self):
        self.algorithm = 'HS256'
        self.access_token_expire = timedelta(minutes=15)
        self.refresh_token_expire = timedelta(days=7)
    
    def authenticate(self, request: HttpRequest, token: str):
        try:
            # í† í° ë””ì½”ë“œ
            payload = jwt.decode(
                token, 
                settings.SECRET_KEY, 
                algorithms=[self.algorithm]
            )
            
            # í† í° ë§Œë£Œ í™•ì¸
            if datetime.utcnow().timestamp() > payload.get('exp', 0):
                logger.warning(f"Expired token from IP: {self.get_client_ip(request)}")
                return None
            
            # ì‚¬ìš©ì ì¡´ì¬ í™•ì¸
            user = User.objects.get(id=payload['user_id'])
            
            # í† í° ë¸”ë™ë¦¬ìŠ¤íŠ¸ í™•ì¸ (Redis ìºì‹œ ì‚¬ìš©)
            if self.is_token_blacklisted(token):
                logger.warning(f"Blacklisted token usage from user: {user.username}")
                return None
                
            return user
            
        except jwt.ExpiredSignatureError:
            logger.warning("Expired JWT token")
            return None
        except jwt.InvalidTokenError:
            logger.warning("Invalid JWT token")
            return None
        except User.DoesNotExist:
            logger.warning("User not found for JWT token")
            return None
        except Exception as e:
            logger.error(f"JWT authentication error: {str(e)}")
            return None
    
    def generate_tokens(self, user):
        """ì•¡ì„¸ìŠ¤ í† í°ê³¼ ë¦¬í”„ë ˆì‹œ í† í° ìƒì„±"""
        now = datetime.utcnow()
        
        # ì•¡ì„¸ìŠ¤ í† í°
        access_payload = {
            'user_id': user.id,
            'username': user.username,
            'exp': now + self.access_token_expire,
            'iat': now,
            'type': 'access',
            'jti': secrets.token_urlsafe(16)  # JWT ID for tracking
        }
        
        # ë¦¬í”„ë ˆì‹œ í† í°
        refresh_payload = {
            'user_id': user.id,
            'exp': now + self.refresh_token_expire,
            'iat': now,
            'type': 'refresh',
            'jti': secrets.token_urlsafe(16)
        }
        
        access_token = jwt.encode(access_payload, settings.SECRET_KEY, algorithm=self.algorithm)
        refresh_token = jwt.encode(refresh_payload, settings.SECRET_KEY, algorithm=self.algorithm)
        
        return {
            'access_token': access_token,
            'refresh_token': refresh_token,
            'token_type': 'bearer',
            'expires_in': self.access_token_expire.total_seconds()
        }
    
    def get_client_ip(self, request):
        """í´ë¼ì´ì–¸íŠ¸ IP ì£¼ì†Œ ì¶”ì¶œ"""
        x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
        if x_forwarded_for:
            ip = x_forwarded_for.split(',')[0]
        else:
            ip = request.META.get('REMOTE_ADDR')
        return ip
    
    def is_token_blacklisted(self, token):
        """í† í° ë¸”ë™ë¦¬ìŠ¤íŠ¸ í™•ì¸ (Redis ì‚¬ìš©)"""
        from django.core.cache import cache
        return cache.get(f"blacklist_{token}") is not None
    
    def blacklist_token(self, token):
        """í† í°ì„ ë¸”ë™ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€"""
        from django.core.cache import cache
        # í† í° ë§Œë£Œ ì‹œê°„ê¹Œì§€ ë¸”ë™ë¦¬ìŠ¤íŠ¸ì— ìœ ì§€
        cache.set(f"blacklist_{token}", True, timeout=86400)  # 24ì‹œê°„

auth = SecureJWTAuth()
```

### 2. API ë ˆì´íŠ¸ ë¦¬ë¯¸íŒ…

```python
# rate_limiting.py
from ninja import NinjaAPI
from django.core.cache import cache
from django.http import JsonResponse
import time
from functools import wraps

class RateLimiter:
    def __init__(self, max_requests=100, window_seconds=3600):
        self.max_requests = max_requests
        self.window_seconds = window_seconds
    
    def __call__(self, func):
        @wraps(func)
        def wrapper(request, *args, **kwargs):
            # í´ë¼ì´ì–¸íŠ¸ ì‹ë³„
            client_id = self.get_client_identifier(request)
            
            # í˜„ì¬ ì‹œê°„ ìœˆë„ìš°
            current_window = int(time.time() // self.window_seconds)
            cache_key = f"rate_limit_{client_id}_{current_window}"
            
            # í˜„ì¬ ìš”ì²­ ìˆ˜ í™•ì¸
            current_requests = cache.get(cache_key, 0)
            
            if current_requests >= self.max_requests:
                return JsonResponse({
                    'error': 'Rate limit exceeded',
                    'retry_after': self.window_seconds
                }, status=429)
            
            # ìš”ì²­ ìˆ˜ ì¦ê°€
            cache.set(cache_key, current_requests + 1, self.window_seconds)
            
            return func(request, *args, **kwargs)
        return wrapper
    
    def get_client_identifier(self, request):
        """í´ë¼ì´ì–¸íŠ¸ ì‹ë³„ì ìƒì„±"""
        # ì¸ì¦ëœ ì‚¬ìš©ìì˜ ê²½ìš° ì‚¬ìš©ì ID ì‚¬ìš©
        if hasattr(request, 'auth') and request.auth:
            return f"user_{request.auth.id}"
        
        # ë¹„ì¸ì¦ ì‚¬ìš©ìì˜ ê²½ìš° IP ì£¼ì†Œ ì‚¬ìš©
        x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
        if x_forwarded_for:
            ip = x_forwarded_for.split(',')[0]
        else:
            ip = request.META.get('REMOTE_ADDR')
        return f"ip_{ip}"

# ì‚¬ìš© ì˜ˆì‹œ
rate_limit = RateLimiter(max_requests=50, window_seconds=3600)  # ì‹œê°„ë‹¹ 50ê°œ ìš”ì²­

@api.get("/public-data")
@rate_limit
def get_public_data(request):
    return {"data": "ê³µê°œ ë°ì´í„°"}

# ë” ì—„ê²©í•œ ì œí•œ
strict_rate_limit = RateLimiter(max_requests=5, window_seconds=60)  # ë¶„ë‹¹ 5ê°œ ìš”ì²­

@api.post("/sensitive-action")
@strict_rate_limit
def sensitive_action(request):
    return {"message": "ë¯¼ê°í•œ ì‘ì—… ì™„ë£Œ"}
```

### 3. ì…ë ¥ ë°ì´í„° ê²€ì¦ ë° Sanitization

```python
# validation.py
from ninja import Schema
from pydantic import validator, Field
import re
import bleach
from typing import Optional

class SecureUserSchema(Schema):
    username: str = Field(..., min_length=3, max_length=30)
    email: str = Field(..., regex=r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$')
    password: str = Field(..., min_length=8)
    bio: Optional[str] = Field(None, max_length=500)
    
    @validator('username')
    def validate_username(cls, v):
        # ì˜ìˆ«ìì™€ ì–¸ë”ìŠ¤ì½”ì–´ë§Œ í—ˆìš©
        if not re.match(r'^[a-zA-Z0-9_]+$', v):
            raise ValueError('ì‚¬ìš©ìëª…ì€ ì˜ìˆ«ìì™€ ì–¸ë”ìŠ¤ì½”ì–´ë§Œ ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤')
        return v.lower()
    
    @validator('password')
    def validate_password(cls, v):
        # ë¹„ë°€ë²ˆí˜¸ ë³µì¡ì„± ê²€ì¦
        if not re.search(r'[A-Z]', v):
            raise ValueError('ëŒ€ë¬¸ìê°€ í¬í•¨ë˜ì–´ì•¼ í•©ë‹ˆë‹¤')
        if not re.search(r'[a-z]', v):
            raise ValueError('ì†Œë¬¸ìê°€ í¬í•¨ë˜ì–´ì•¼ í•©ë‹ˆë‹¤')
        if not re.search(r'[0-9]', v):
            raise ValueError('ìˆ«ìê°€ í¬í•¨ë˜ì–´ì•¼ í•©ë‹ˆë‹¤')
        if not re.search(r'[!@#$%^&*(),.?":{}|<>]', v):
            raise ValueError('íŠ¹ìˆ˜ë¬¸ìê°€ í¬í•¨ë˜ì–´ì•¼ í•©ë‹ˆë‹¤')
        return v
    
    @validator('bio')
    def sanitize_bio(cls, v):
        if v is None:
            return v
        
        # HTML íƒœê·¸ ì œê±° (ì¼ë¶€ ì•ˆì „í•œ íƒœê·¸ëŠ” í—ˆìš©)
        allowed_tags = ['b', 'i', 'u', 'em', 'strong']
        cleaned = bleach.clean(v, tags=allowed_tags, strip=True)
        return cleaned

class SecurePostSchema(Schema):
    title: str = Field(..., min_length=1, max_length=200)
    content: str = Field(..., min_length=1, max_length=10000)
    tags: list[str] = Field(default=[], max_items=10)
    
    @validator('title', 'content')
    def prevent_xss(cls, v):
        # XSS ê³µê²© íŒ¨í„´ íƒì§€
        xss_patterns = [
            r'<script[^>]*>.*?</script>',
            r'javascript:',
            r'on\w+\s*=',
            r'<iframe[^>]*>.*?</iframe>',
        ]
        
        for pattern in xss_patterns:
            if re.search(pattern, v, re.IGNORECASE):
                raise ValueError('ì ì¬ì ìœ¼ë¡œ ìœ„í—˜í•œ ì½˜í…ì¸ ê°€ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤')
        
        return bleach.clean(v, strip=True)
    
    @validator('tags')
    def validate_tags(cls, v):
        # íƒœê·¸ ê¸¸ì´ ë° í˜•ì‹ ê²€ì¦
        cleaned_tags = []
        for tag in v:
            if len(tag) > 20:
                raise ValueError('íƒœê·¸ëŠ” 20ìë¥¼ ì´ˆê³¼í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤')
            if not re.match(r'^[a-zA-Z0-9ê°€-í£_-]+$', tag):
                raise ValueError('íƒœê·¸ì— íŠ¹ìˆ˜ë¬¸ìëŠ” ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤')
            cleaned_tags.append(tag.strip().lower())
        
        return list(set(cleaned_tags))  # ì¤‘ë³µ ì œê±°
```

### 4. API ê¶Œí•œ ê´€ë¦¬

```python
# permissions.py
from ninja import NinjaAPI
from django.http import JsonResponse
from functools import wraps
import logging

logger = logging.getLogger('security')

def require_permission(permission_name):
    """ê¶Œí•œ ê¸°ë°˜ ì ‘ê·¼ ì œì–´ ë°ì½”ë ˆì´í„°"""
    def decorator(func):
        @wraps(func)
        def wrapper(request, *args, **kwargs):
            if not request.user.is_authenticated:
                logger.warning(f"Unauthenticated access attempt to {func.__name__}")
                return JsonResponse({'error': 'ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤'}, status=401)
            
            if not request.user.has_perm(permission_name):
                logger.warning(f"Permission denied for user {request.user.username} on {func.__name__}")
                return JsonResponse({'error': 'ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤'}, status=403)
            
            return func(request, *args, **kwargs)
        return wrapper
    return decorator

def require_ownership_or_admin(model_class, param_name='id'):
    """ê°ì²´ ì†Œìœ ê¶Œ ë˜ëŠ” ê´€ë¦¬ì ê¶Œí•œ í™•ì¸"""
    def decorator(func):
        @wraps(func)
        def wrapper(request, *args, **kwargs):
            if not request.user.is_authenticated:
                return JsonResponse({'error': 'ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤'}, status=401)
            
            # ê°ì²´ ID ì¶”ì¶œ
            obj_id = kwargs.get(param_name)
            if not obj_id:
                return JsonResponse({'error': 'ì˜ëª»ëœ ìš”ì²­ì…ë‹ˆë‹¤'}, status=400)
            
            try:
                obj = model_class.objects.get(id=obj_id)
            except model_class.DoesNotExist:
                return JsonResponse({'error': 'ê°ì²´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤'}, status=404)
            
            # ì†Œìœ ê¶Œ ë˜ëŠ” ê´€ë¦¬ì ê¶Œí•œ í™•ì¸
            if not (request.user.is_staff or 
                   (hasattr(obj, 'owner') and obj.owner == request.user) or
                   (hasattr(obj, 'author') and obj.author == request.user)):
                logger.warning(f"Ownership violation: user {request.user.username} tried to access {model_class.__name__} {obj_id}")
                return JsonResponse({'error': 'ì ‘ê·¼ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤'}, status=403)
            
            return func(request, *args, **kwargs)
        return wrapper
    return decorator

# ì‚¬ìš© ì˜ˆì‹œ
from .models import Post

@api.get("/admin/users")
@require_permission('auth.view_user')
def list_users(request):
    return {"users": "ì‚¬ìš©ì ëª©ë¡"}

@api.delete("/posts/{int:post_id}")
@require_ownership_or_admin(Post, 'post_id')
def delete_post(request, post_id: int):
    Post.objects.filter(id=post_id).delete()
    return {"message": "ê²Œì‹œê¸€ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤"}
```

## ğŸš¨ ì£¼ìš” ë³´ì•ˆ ì·¨ì•½ì ê³¼ ëŒ€ì‘ ë°©ì•ˆ

### 1. ì¸ì¦ ìš°íšŒ ê³µê²©

**ì·¨ì•½ì :**
```python
# ìœ„í—˜í•œ ì½”ë“œ
@api.get("/user/{int:user_id}/profile")
def get_user_profile(request, user_id: int):
    # ì¸ì¦ í™•ì¸ ì—†ì´ ëª¨ë“  ì‚¬ìš©ì ì •ë³´ ë°˜í™˜
    user = User.objects.get(id=user_id)
    return {"username": user.username, "email": user.email}
```

**ë³´ì•ˆ ê°•í™”:**
```python
# ì•ˆì „í•œ ì½”ë“œ
@api.get("/user/{int:user_id}/profile", auth=auth)
def get_user_profile(request, user_id: int):
    # ìì‹ ì˜ ì •ë³´ë§Œ ì¡°íšŒ ê°€ëŠ¥í•˜ë„ë¡ ì œí•œ
    if request.user.id != user_id and not request.user.is_staff:
        return JsonResponse({'error': 'ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤'}, status=403)
    
    user = User.objects.get(id=user_id)
    return {
        "username": user.username,
        "email": user.email if request.user.id == user_id else None
    }
```

### 2. ë¯¼ê°í•œ ì •ë³´ ë…¸ì¶œ

**ì·¨ì•½ì :**
```python
# ìœ„í—˜í•œ ì½”ë“œ - ëª¨ë“  ì •ë³´ ë°˜í™˜
@api.get("/users", response=List[UserSchema])
def list_users(request):
    return User.objects.all()

class UserSchema(ModelSchema):
    class Config:
        model = User
        model_fields = "__all__"  # ë¹„ë°€ë²ˆí˜¸ ë“± ë¯¼ê°í•œ ì •ë³´ í¬í•¨
```

**ë³´ì•ˆ ê°•í™”:**
```python
# ì•ˆì „í•œ ì½”ë“œ - í•„ìš”í•œ ì •ë³´ë§Œ ë°˜í™˜
class PublicUserSchema(ModelSchema):
    class Config:
        model = User
        model_fields = ["id", "username", "date_joined"]  # ê³µê°œ ì •ë³´ë§Œ

class PrivateUserSchema(ModelSchema):
    class Config:
        model = User
        model_fields = ["id", "username", "email", "first_name", "last_name"]
        # ë¹„ë°€ë²ˆí˜¸, í† í° ë“± ë¯¼ê°í•œ ì •ë³´ ì œì™¸

@api.get("/users", response=List[PublicUserSchema])
def list_users(request):
    return User.objects.filter(is_active=True)

@api.get("/me", auth=auth, response=PrivateUserSchema)
def get_my_profile(request):
    return request.user
```

### 3. íŒŒì¼ ì—…ë¡œë“œ ì·¨ì•½ì 

```python
# file_upload.py
import os
import magic
from django.conf import settings
from django.core.files.storage import default_storage
from ninja import File, UploadedFile

class SecureFileUploader:
    ALLOWED_EXTENSIONS = {'.jpg', '.jpeg', '.png', '.gif', '.pdf', '.txt', '.docx'}
    ALLOWED_MIME_TYPES = {
        'image/jpeg', 'image/png', 'image/gif',
        'application/pdf', 'text/plain',
        'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
    }
    MAX_FILE_SIZE = 10 * 1024 * 1024  # 10MB
    
    @staticmethod
    def validate_file(file: UploadedFile):
        """íŒŒì¼ ë³´ì•ˆ ê²€ì¦"""
        # íŒŒì¼ í¬ê¸° í™•ì¸
        if file.size > SecureFileUploader.MAX_FILE_SIZE:
            raise ValueError('íŒŒì¼ í¬ê¸°ê°€ ë„ˆë¬´ í½ë‹ˆë‹¤ (ìµœëŒ€ 10MB)')
        
        # íŒŒì¼ í™•ì¥ì í™•ì¸
        file_ext = os.path.splitext(file.name)[1].lower()
        if file_ext not in SecureFileUploader.ALLOWED_EXTENSIONS:
            raise ValueError(f'í—ˆìš©ë˜ì§€ ì•ŠëŠ” íŒŒì¼ í˜•ì‹ì…ë‹ˆë‹¤: {file_ext}')
        
        # MIME íƒ€ì… í™•ì¸ (ì‹¤ì œ íŒŒì¼ ë‚´ìš© ê¸°ë°˜)
        file_content = file.read()
        file.seek(0)  # íŒŒì¼ í¬ì¸í„° ë¦¬ì…‹
        
        mime_type = magic.from_buffer(file_content, mime=True)
        if mime_type not in SecureFileUploader.ALLOWED_MIME_TYPES:
            raise ValueError(f'í—ˆìš©ë˜ì§€ ì•ŠëŠ” MIME íƒ€ì…ì…ë‹ˆë‹¤: {mime_type}')
        
        # íŒŒì¼ëª… sanitization
        safe_filename = SecureFileUploader.sanitize_filename(file.name)
        return safe_filename
    
    @staticmethod
    def sanitize_filename(filename):
        """íŒŒì¼ëª… ì•ˆì „í•˜ê²Œ ë³€ê²½"""
        import re
        import uuid
        
        # ìœ„í—˜í•œ ë¬¸ì ì œê±°
        safe_name = re.sub(r'[^\w\s.-]', '', filename)
        safe_name = re.sub(r'[-\s]+', '-', safe_name)
        
        # ê³ ìœ í•œ íŒŒì¼ëª… ìƒì„±
        name, ext = os.path.splitext(safe_name)
        unique_name = f"{name}_{uuid.uuid4().hex[:8]}{ext}"
        
        return unique_name

@api.post("/upload")
def upload_file(request, file: UploadedFile = File(...)):
    try:
        # íŒŒì¼ ë³´ì•ˆ ê²€ì¦
        safe_filename = SecureFileUploader.validate_file(file)
        
        # ì•ˆì „í•œ ê²½ë¡œì— ì €ì¥
        file_path = default_storage.save(
            f"uploads/{safe_filename}",
            file
        )
        
        return {
            "message": "íŒŒì¼ì´ ì•ˆì „í•˜ê²Œ ì—…ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤",
            "filename": safe_filename,
            "path": file_path
        }
    
    except ValueError as e:
        return JsonResponse({"error": str(e)}, status=400)
    except Exception as e:
        logger.error(f"File upload error: {str(e)}")
        return JsonResponse({"error": "íŒŒì¼ ì—…ë¡œë“œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤"}, status=500)
```

### 4. API ë²„ì „ ê´€ë¦¬ì™€ ë³´ì•ˆ

```python
# versioning.py
from ninja import NinjaAPI

# API ë²„ì „ë³„ ë³´ì•ˆ ì •ì±…
api_v1 = NinjaAPI(version="1.0", url_namespace="v1")
api_v2 = NinjaAPI(version="2.0", url_namespace="v2")

# V1 - ë ˆê±°ì‹œ (ë” ì—„ê²©í•œ ë³´ì•ˆ)
@api_v1.get("/users", auth=auth)
@rate_limit
def list_users_v1(request):
    # ì¸ì¦ëœ ê´€ë¦¬ìë§Œ ì ‘ê·¼ ê°€ëŠ¥
    if not request.user.is_staff:
        return JsonResponse({"error": "ê´€ë¦¬ì ê¶Œí•œ í•„ìš”"}, status=403)
    return {"users": "v1 ì‚¬ìš©ì ëª©ë¡"}

# V2 - ìµœì‹  (ê°œì„ ëœ ë³´ì•ˆê³¼ ê¸°ëŠ¥)
@api_v2.get("/users", auth=auth)
@require_permission('auth.view_user')
def list_users_v2(request):
    # ê¶Œí•œ ê¸°ë°˜ ì ‘ê·¼ ì œì–´
    return {"users": "v2 ì‚¬ìš©ì ëª©ë¡", "features": ["pagination", "filtering"]}

# API ì‚¬ìš© ì¤‘ë‹¨ ê²½ê³ 
@api_v1.get("/deprecated-endpoint")
def deprecated_endpoint(request):
    return {
        "warning": "ì´ ì—”ë“œí¬ì¸íŠ¸ëŠ” ê³§ ì œê±°ë©ë‹ˆë‹¤. v2 APIë¥¼ ì‚¬ìš©í•˜ì„¸ìš”",
        "migration_guide": "/docs/migration-v1-to-v2"
    }
```

## ğŸ” ë³´ì•ˆ ëª¨ë‹ˆí„°ë§ ë° ë¡œê¹…

```python
# security_monitoring.py
import logging
from django.utils import timezone
from django.contrib.auth.signals import user_logged_in, user_login_failed
from django.dispatch import receiver
from django.contrib.auth.models import User

# ë³´ì•ˆ ì´ë²¤íŠ¸ ë¡œê±° ì„¤ì •
security_logger = logging.getLogger('security')

class SecurityEvent:
    """ë³´ì•ˆ ì´ë²¤íŠ¸ ì¶”ì """
    
    @staticmethod
    def log_login_success(user, request):
        security_logger.info(
            f"LOGIN_SUCCESS: User {user.username} from {SecurityEvent.get_client_ip(request)}"
        )
    
    @staticmethod
    def log_login_failure(username, request):
        security_logger.warning(
            f"LOGIN_FAILED: Username {username} from {SecurityEvent.get_client_ip(request)}"
        )
    
    @staticmethod
    def log_permission_denied(user, resource, request):
        security_logger.warning(
            f"PERMISSION_DENIED: User {user.username} tried to access {resource} from {SecurityEvent.get_client_ip(request)}"
        )
    
    @staticmethod
    def log_rate_limit_exceeded(identifier, request):
        security_logger.warning(
            f"RATE_LIMIT_EXCEEDED: {identifier} from {SecurityEvent.get_client_ip(request)}"
        )
    
    @staticmethod
    def get_client_ip(request):
        x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
        if x_forwarded_for:
            ip = x_forwarded_for.split(',')[0]
        else:
            ip = request.META.get('REMOTE_ADDR')
        return ip

# Django ì‹ í˜¸ë¥¼ í†µí•œ ìë™ ë¡œê¹…
@receiver(user_logged_in)
def log_user_login(sender, request, user, **kwargs):
    SecurityEvent.log_login_success(user, request)

@receiver(user_login_failed)
def log_user_login_failed(sender, credentials, request, **kwargs):
    username = credentials.get('username', 'unknown')
    SecurityEvent.log_login_failure(username, request)

# ì˜ì‹¬ìŠ¤ëŸ¬ìš´ í™œë™ íƒì§€
class SecurityAnalyzer:
    @staticmethod
    def detect_brute_force(username, ip_address):
        """ë¬´ì°¨ë³„ ëŒ€ì… ê³µê²© íƒì§€"""
        from django.core.cache import cache
        
        key = f"failed_login_{username}_{ip_address}"
        failed_attempts = cache.get(key, 0)
        
        if failed_attempts >= 5:
            # ê³„ì • ì„ì‹œ ì ê¸ˆ
            SecurityAnalyzer.temporary_lock_account(username)
            security_logger.critical(
                f"BRUTE_FORCE_DETECTED: {failed_attempts} failed attempts for {username} from {ip_address}"
            )
            return True
        
        return False
    
    @staticmethod
    def temporary_lock_account(username, duration=3600):
        """ê³„ì • ì„ì‹œ ì ê¸ˆ (1ì‹œê°„)"""
        from django.core.cache import cache
        cache.set(f"locked_account_{username}", True, duration)
    
    @staticmethod
    def is_account_locked(username):
        """ê³„ì • ì ê¸ˆ ìƒíƒœ í™•ì¸"""
        from django.core.cache import cache
        return cache.get(f"locked_account_{username}", False)
```

## âš™ï¸ í”„ë¡œë•ì…˜ ë³´ì•ˆ ì„¤ì •

```python
# settings/production.py
import os

# ê¸°ë³¸ ë³´ì•ˆ ì„¤ì •
DEBUG = False
SECRET_KEY = os.environ.get('SECRET_KEY')  # í™˜ê²½ë³€ìˆ˜ì—ì„œ ë¡œë“œ

# HTTPS ê°•ì œ
SECURE_SSL_REDIRECT = True
SECURE_PROXY_SSL_HEADER = ('HTTP_X_FORWARDED_PROTO', 'https')

# ë³´ì•ˆ í—¤ë”
SECURE_BROWSER_XSS_FILTER = True
SECURE_CONTENT_TYPE_NOSNIFF = True
SECURE_HSTS_SECONDS = 31536000  # 1ë…„
SECURE_HSTS_INCLUDE_SUBDOMAINS = True
SECURE_HSTS_PRELOAD = True

# ì¿ í‚¤ ë³´ì•ˆ
SESSION_COOKIE_SECURE = True
SESSION_COOKIE_HTTPONLY = True
SESSION_COOKIE_SAMESITE = 'Strict'
CSRF_COOKIE_SECURE = True
CSRF_COOKIE_HTTPONLY = True

# í—ˆìš©ëœ í˜¸ìŠ¤íŠ¸
ALLOWED_HOSTS = [
    'yourdomain.com',
    'www.yourdomain.com',
]

# ë³´ì•ˆ ë¯¸ë“¤ì›¨ì–´
MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'corsheaders.middleware.CorsMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    'your_app.middleware.SecurityMiddleware',  # ì»¤ìŠ¤í…€ ë³´ì•ˆ ë¯¸ë“¤ì›¨ì–´
]

# ë°ì´í„°ë² ì´ìŠ¤ ë³´ì•ˆ
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': os.environ.get('DB_NAME'),
        'USER': os.environ.get('DB_USER'),
        'PASSWORD': os.environ.get('DB_PASSWORD'),
        'HOST': os.environ.get('DB_HOST'),
        'PORT': os.environ.get('DB_PORT', '5432'),
        'OPTIONS': {
            'sslmode': 'require',  # SSL ì—°ê²° ê°•ì œ
        },
    }
}

# ë¡œê¹… ì„¤ì •
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'security': {
            'format': '[{asctime}] {levelname} {name}: {message}',
            'style': '{',
        },
    },
    'handlers': {
        'security_file': {
            'level': 'INFO',
            'class': 'logging.handlers.RotatingFileHandler',
            'filename': '/var/log/django/security.log',
            'maxBytes': 10485760,  # 10MB
            'backupCount': 5,
            'formatter': 'security',
        },
    },
    'loggers': {
        'security': {
            'handlers': ['security_file'],
            'level': 'INFO',
            'propagate': False,
        },
    },
}
```

## ğŸ› ï¸ ë³´ì•ˆ í…ŒìŠ¤íŠ¸

```python
# tests/test_security.py
from django.test import TestCase, Client
from django.contrib.auth.models import User
from ninja.testing import TestClient
from your_app.api import api
import json

class SecurityTestCase(TestCase):
    def setUp(self):
        self.client = TestClient(api)
        self.user = User.objects.create_user(
            username='testuser',
            email='test@example.com',
            password='TestPass123!'
        )
    
    def test_csrf_protection(self):
        """CSRF ë³´í˜¸ í…ŒìŠ¤íŠ¸"""
        response = self.client.post('/api/protected-endpoint', {
            'data': 'test'
        })
        self.assertEqual(response.status_code, 403)  # CSRF í† í° ì—†ìŒ
    
    def test_xss_prevention(self):
        """XSS ë°©ì§€ í…ŒìŠ¤íŠ¸"""
        malicious_input = '<script>alert("xss")</script>'
        response = self.client.post('/api/comments', {
            'content': malicious_input,
            'author': 'test'
        })
        
        # ìŠ¤í¬ë¦½íŠ¸ íƒœê·¸ê°€ ì œê±°ë˜ì–´ì•¼ í•¨
        self.assertNotIn('<script>', response.json().get('content', ''))
    
    def test_sql_injection_prevention(self):
        """SQL Injection ë°©ì§€ í…ŒìŠ¤íŠ¸"""
        malicious_input = "'; DROP TABLE users; --"
        response = self.client.get(f'/api/users/{malicious_input}')
        
        # 400 ì—ëŸ¬ ë˜ëŠ” ì•ˆì „í•œ ì²˜ë¦¬
        self.assertIn(response.status_code, [400, 404])
    
    def test_rate_limiting(self):
        """ë ˆì´íŠ¸ ë¦¬ë¯¸íŒ… í…ŒìŠ¤íŠ¸"""
        # ì—°ì†ìœ¼ë¡œ ë§ì€ ìš”ì²­ ë³´ë‚´ê¸°
        for i in range(10):
            response = self.client.get('/api/public-data')
        
        # ì¼ì • ìˆ˜ ì´ìƒ ìš”ì²­ ì‹œ 429 ì—ëŸ¬
        response = self.client.get('/api/public-data')
        if response.status_code == 429:
            self.assertEqual(response.status_code, 429)
    
    def test_authentication_required(self):
        """ì¸ì¦ í•„ìš” ì—”ë“œí¬ì¸íŠ¸ í…ŒìŠ¤íŠ¸"""
        response = self.client.get('/api/protected-resource')
        self.assertEqual(response.status_code, 401)
    
    def test_authorization_enforcement(self):
        """ê¶Œí•œ í™•ì¸ í…ŒìŠ¤íŠ¸"""
        # ë‹¤ë¥¸ ì‚¬ìš©ìì˜ ë¦¬ì†ŒìŠ¤ ì ‘ê·¼ ì‹œë„
        other_user = User.objects.create_user(
            username='otheruser',
            password='TestPass123!'
        )
        
        self.client.force_authenticate(self.user)
        response = self.client.get(f'/api/users/{other_user.id}/private-data')
        self.assertEqual(response.status_code, 403)
```

## ğŸ“‹ ë³´ì•ˆ ì²´í¬ë¦¬ìŠ¤íŠ¸

### Django ê¸°ë³¸ ë³´ì•ˆ
- [ ] `DEBUG = False` (í”„ë¡œë•ì…˜)
- [ ] ê°•ë ¥í•œ `SECRET_KEY` ì„¤ì •
- [ ] HTTPS ê°•ì œ (`SECURE_SSL_REDIRECT = True`)
- [ ] ë³´ì•ˆ í—¤ë” ì„¤ì •
- [ ] í—ˆìš©ëœ í˜¸ìŠ¤íŠ¸ ì œí•œ (`ALLOWED_HOSTS`)
- [ ] CSRF ë³´í˜¸ í™œì„±í™”
- [ ] ì„¸ì…˜ ì¿ í‚¤ ë³´ì•ˆ ì„¤ì •

### Django Ninja API ë³´ì•ˆ
- [ ] JWT í† í° ë§Œë£Œ ì‹œê°„ ì„¤ì •
- [ ] API ë ˆì´íŠ¸ ë¦¬ë¯¸íŒ… êµ¬í˜„
- [ ] ì…ë ¥ ë°ì´í„° ê²€ì¦ ë° sanitization
- [ ] ê¶Œí•œ ê¸°ë°˜ ì ‘ê·¼ ì œì–´
- [ ] íŒŒì¼ ì—…ë¡œë“œ ë³´ì•ˆ ê²€ì¦
- [ ] API ë²„ì „ ê´€ë¦¬

### ëª¨ë‹ˆí„°ë§ ë° ë¡œê¹…
- [ ] ë³´ì•ˆ ì´ë²¤íŠ¸ ë¡œê¹…
- [ ] ë¬´ì°¨ë³„ ëŒ€ì… ê³µê²© íƒì§€
- [ ] ì˜ì‹¬ìŠ¤ëŸ¬ìš´ í™œë™ ëª¨ë‹ˆí„°ë§
- [ ] ì •ê¸°ì ì¸ ë³´ì•ˆ ê°ì‚¬

## ğŸ¯ ê²°ë¡ 

Djangoì™€ Django NinjaëŠ” ê°•ë ¥í•œ ë³´ì•ˆ ê¸°ëŠ¥ì„ ì œê³µí•˜ì§€ë§Œ, ê°œë°œìê°€ ì˜¬ë°”ë¥´ê²Œ êµ¬í˜„í•´ì•¼ íš¨ê³¼ì ì…ë‹ˆë‹¤. ì£¼ìš” í¬ì¸íŠ¸ëŠ”:

1. **ê¸°ë³¸ ë³´ì•ˆ ì„¤ì •**: Djangoì˜ ê¸°ë³¸ ë³´ì•ˆ ê¸°ëŠ¥ì„ ëª¨ë‘ í™œì„±í™”
2. **API íŠ¹í™” ë³´ì•ˆ**: JWT ì¸ì¦, ë ˆì´íŠ¸ ë¦¬ë¯¸íŒ…, ì…ë ¥ ê²€ì¦
3. **ì§€ì†ì ì¸ ëª¨ë‹ˆí„°ë§**: ë³´ì•ˆ ì´ë²¤íŠ¸ ì¶”ì  ë° ë¶„ì„
4. **ì •ê¸°ì ì¸ ì—…ë°ì´íŠ¸**: ë³´ì•ˆ íŒ¨ì¹˜ ë° ì˜ì¡´ì„± ì—…ë°ì´íŠ¸

ë³´ì•ˆì€ í•œ ë²ˆ ì„¤ì •í•˜ê³  ëë‚˜ëŠ” ê²ƒì´ ì•„ë‹ˆë¼ ì§€ì†ì ìœ¼ë¡œ ê´€ë¦¬í•´ì•¼ í•˜ëŠ” ì˜ì—­ì…ë‹ˆë‹¤. ì •ê¸°ì ì¸ ë³´ì•ˆ ê°ì‚¬ì™€ ìµœì‹  ë³´ì•ˆ ë™í–¥ íŒŒì•…ì„ í†µí•´ ì•ˆì „í•œ ì›¹ ì„œë¹„ìŠ¤ë¥¼ ìœ ì§€í•˜ì‹œê¸° ë°”ëë‹ˆë‹¤.
